---
title: "Interpolation and Composition"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Interpolation and Composition}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Composition builds one final config from multiple YAML files. In `hydraR`, this is controlled by `compose(config_name = ...)`, `defaults`, and `_self_`.

## Directory and files

To illustrate how to use these features, we will use YAML files distributed
alongside the `hydraR` package: `minimal.yml`, `main.yml`, `combine.yml`,
`db/mysql.yml`, and `db/postgres.yml`. These files are stored in the
`examples/` directory of the package. We can find this directory on the file
system using:

```r
system.file("examples", package = "hydraR")

[1] "/path/to/R/library/hydraR/examples"
```

To avoid specifying the config directory path and config name every time we call
`compose()`, we set global options:

```{r setup}
library(hydraR)

options(
  hydraR.compose.config_path = system.file("examples", package = "hydraR"),
  hydraR.compose.config_name = "main"
)
```

The first config file we will use is: `minimal.yml`

```{r show-minimal-yaml, echo=FALSE, results='asis'}
cat("```yaml\n")
cat(paste(readLines(file.path(getOption("hydraR.compose.config_path"), "minimal.yml")), collapse = "\n"))
cat("\n```\n")
```

The second config file is: `main.yml`

```{r show-main-yaml, echo=FALSE, results='asis'}
cat("```yaml\n")
cat(paste(readLines(file.path(getOption("hydraR.compose.config_path"), "main.yml")), collapse = "\n"))
cat("\n```\n")
```

## Interpolation

As you can see above, `main.yml` uses many placeholders and nested values. These placeholders are interpolated and resolved when calling `compose()` or `main()`. 

```{r}
cfg <- compose()
```

For example, the `url` field is defined as `"http://${server.host}:${server.port}/"`. The placeholders are resolved at compose time by extracting the relevant information from other fields in the YAML file, and return:

```{r}
cfg$client$url
```

We can also use complex, nested, indexing as in the `plan` field: `${plans[${selected_plan}]}`

```{r}
cfg$plan
```

## Switch root config

Switch complete entrypoints by changing `config_name`.

```{r}
cfg <- compose(config_name = "minimal")
print(cfg)

cfg <- compose()
print(cfg)
```

## Combining config files

To illustrate how to combine multiple config files, we use the `combine.yml` config distributed with `hydraR`:

```{r, echo=FALSE, results='asis'}
fn <- system.file("examples", "combine.yml", package = "hydraR")
cat("```yaml\n")
cat(paste(readLines(fn), collapse = "\n"))
cat("\n```\n")
```

Note that there is one `db` group member (`mysql` by default) and a `_self_` token.

The `_self_` token means "merge the current file here in the order." Because `_self_` is listed last in `combine.yml`, values in `combine.yml` override values from included files when they overlap. 

```{r}
compose(config_name = "combine")

compose(
  config_name = "combine",
  overrides = c("db=postgres")
)
```
