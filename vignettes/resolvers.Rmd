---
title: "Resolvers"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Resolvers}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Config files often need placeholders that resolve at runtime: environment variables, references to other fields, or typed values decoded from text.
In `hydraR`, this is done with resolvers in expressions like `${resolver:args}` during `compose()`.

`hydraR` currently supports:

- `oc.env`: read an environment variable, with optional fallback.
- `oc.select`: read another config path, with optional fallback.
- `oc.decode`: parse scalar text into YAML-typed values.
- `oc.create`: build list or map values from inline YAML text.
- `oc.deprecated`: warn and redirect an old key to a new key.
- `oc.dict.keys`: return the keys of a mapping.
- `oc.dict.values`: return the values of a mapping.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(hydraR.print.max_depth = 10L, hydraR.print.values = TRUE)
```

```{r setup, echo=FALSE}
library(hydraR)

resolver_demo_dir <- file.path(tempdir(), "hydraR-resolvers-demo")
dir.create(resolver_demo_dir, recursive = TRUE, showWarnings = FALSE)

write_cfg <- function(rel_path, yaml_text, root = resolver_demo_dir) {
  path <- file.path(root, rel_path)
  dir.create(dirname(path), recursive = TRUE, showWarnings = FALSE)
  stem <- sub("\\.(ya?ml)$", "", path)
  unlink(c(paste0(stem, ".yml"), paste0(stem, ".yaml")), force = TRUE)
  writeLines(yaml_text, path, useBytes = TRUE)
  invisible(path)
}
```

## `oc.env`

Read an environment variable, optionally with a fallback.

Directory structure:

```text
conf/
`- example.yml
```

Config file:

```yaml
defaults:
  - _self_
shell: '${oc.env:SHELL,/bin/sh}'
unknown: '${oc.env:hydraR_DEMO_FALLBACK,default_from_fallback}'
error: '${oc.env:hydraR_DEMO_FALLBACK,???}'
```

```{r oc-env-write, echo=FALSE}
yml <- "
defaults:
  - _self_
shell: '${oc.env:SHELL,/bin/sh}'
unknown: '${oc.env:hydraR_DEMO_FALLBACK,default_from_fallback}'
error: '${oc.env:hydraR_DEMO_FALLBACK,???}'
"
write_cfg("example.yml", yml)
```

R code:

```{r}
Sys.unsetenv("hydraR_DEMO_FALLBACK")
cfg <- compose(config_path = resolver_demo_dir, config_name = "example")
print(cfg)
```

## `oc.select`

Read a key if it exists, otherwise use an optional fallback.

Directory structure:

```text
conf/
`- example.yml
```

Config file:

```yaml
defaults:
  - _self_
server:
  port: 8080
selected_existing: '${oc.select:server.port,80}'
selected_missing_with_default: '${oc.select:server.missing,80}'
selected_missing_null: '${oc.select:server.missing}'
```

```{r oc-select-write, echo=FALSE}
yml <- "
defaults:
  - _self_
server:
  port: 8080
selected_existing: '${oc.select:server.port,80}'
selected_missing_with_default: '${oc.select:server.missing,80}'
selected_missing_null: '${oc.select:server.missing}'
"
write_cfg("example.yml", yml)
```

R code:

```{r}
cfg <- compose(config_path = resolver_demo_dir, config_name = "example")
print(cfg)
```

## `oc.decode`

Parse a scalar string as YAML.

Directory structure:

```text
conf/
`- example.yml
```

Config file:

```yaml
defaults:
  - _self_
decoded_int: '${oc.decode:3307}'
decoded_list: '${oc.decode:"[n1, n2]"}'
decoded_dict: '${oc.decode:"{a: 1, b: 2}"}'
decoded_null: '${oc.decode:null}'
```

```{r oc-decode-write, echo=FALSE}
yml <- "
defaults:
  - _self_
decoded_int: '${oc.decode:3307}'
decoded_list: '${oc.decode:\"[n1, n2]\"}'
decoded_dict: '${oc.decode:\"{a: 1, b: 2}\"}'
decoded_null: '${oc.decode:null}'
"
write_cfg("example.yml", yml)
```

R code:

```{r}
cfg <- compose(config_path = resolver_demo_dir, config_name = "example")
print(cfg)
```

## `oc.create`

Create structured values from YAML-like input.

Directory structure:

```text
conf/
`- example.yml
```

Config file:

```yaml
defaults:
  - _self_
created_map: '${oc.create:{alpha: 1, beta: 2}}'
created_list: '${oc.create:[1, 2, 3]}'
```

```{r oc-create-write, echo=FALSE}
yml <- "
defaults:
  - _self_
created_map: '${oc.create:{alpha: 1, beta: 2}}'
created_list: '${oc.create:[1, 2, 3]}'
"
write_cfg("example.yml", yml)
```

R code:

```{r}
cfg <- compose(config_path = resolver_demo_dir, config_name = "example")
print(cfg)
```

## `oc.deprecated`

Mark an old key as deprecated and redirect to a new key.

Directory structure:

```text
conf/
`- example.yml
```

Config file:

```yaml
defaults:
  - _self_
new_key: 42
old_key: '${oc.deprecated:new_key}'
old_key_custom: '${oc.deprecated:new_key,"$OLD_KEY -> $NEW_KEY"}'
```

```{r oc-deprecated-write, echo=FALSE}
yml <- "
defaults:
  - _self_
new_key: 42
old_key: '${oc.deprecated:new_key}'
old_key_custom: '${oc.deprecated:new_key,\"$OLD_KEY -> $NEW_KEY\"}'
"
write_cfg("example.yml", yml)
```

R code:

```{r}
cfg <- compose(config_path = resolver_demo_dir, config_name = "example")
print(cfg)
```

## `oc.dict.keys` and `oc.dict.values`

Read keys or values from a mapping.

Directory structure:

```text
conf/
`- example.yml
```

Config file:

```yaml
defaults:
  - _self_
models:
  tiny:
    lr: 0.001
  base:
    lr: 0.0005
model_names: '${oc.dict.keys:models}'
model_values: '${oc.dict.values:models}'
```

```{r oc-dict-write, echo=FALSE}
yml <- "
defaults:
  - _self_
models:
  tiny:
    lr: 0.001
  base:
    lr: 0.0005
model_names: '${oc.dict.keys:models}'
model_values: '${oc.dict.values:models}'
"
write_cfg("example.yml", yml)
```

R code:

```{r}
cfg <- compose(config_path = resolver_demo_dir, config_name = "example")
print(cfg)
```
